#!/usr/bin/env node

const _ = require('lodash');
const {deployToServer, buildCode} = require('..');
const {getUserHome, readJson, existsFile, parseTpl} = require('../src/util');
const yargs = require('yargs');
const fs = require('fs');
const path = require('path');
const log = console.log; // eslint-disable-line

yargs.usage(`Usage: ideploy
  --config        config json file path
  --env           used for config
  --buildOnly     build only
  --publishOnly   publish only
  --onlineType    online type, production, staging, ...
  --pktRepo       pkt repo
    `).help('h').alias('h', 'help');

const {
  argv
} = yargs;

/**
 * obj = {env, project}
 */
const resolveConfigDef = (def, obj) => {
  const ret = {};

  if(def.remoteDir) {
    ret.remoteDir = parseTpl(def.remoteDir, obj);
  }

  if(def.dockerComposeYml) {
    ret.dockerComposeYml = parseTpl(def.dockerComposeYml, obj);
  }

  if(def.healthJob) {
    ret.healthJob = (def.healthJob || []).map((item) => parseTpl(item, obj));
  }

  return ret;
};

const resolveSSHConfig = (sshConfigs, configDir) => {
  if(!sshConfigs) {
    throw new Error('missing configuration of sshConfigs');
  }

  const defaultPrivateKeyFile = path.resolve(getUserHome(), '.ssh/id_rsa');

  for(let name in sshConfigs) {
    const obj = sshConfigs[name];
    const options = obj.options;
    // resolve private key
    if(!options.privateKey) {
      options.privateKeyFile = options.privateKeyFile || defaultPrivateKeyFile;
      options.privateKey = fs.readFileSync(path.resolve(configDir, options.privateKeyFile), 'utf-8');
      delete options.privateKeyFile;
    }
    obj.options = options;

    // resolve proxy private key
    const proxyOptions = obj.proxyOptions;
    if(proxyOptions) {
      if(!proxyOptions.privateKey) {
        proxyOptions.privateKeyFile = proxyOptions.privateKeyFile || defaultPrivateKeyFile;
        proxyOptions.privateKey = fs.readFileSync(path.resolve(configDir, proxyOptions.privateKeyFile), 'utf-8');
        delete proxyOptions.privateKeyFile;
      }
      obj.proxyOptions = proxyOptions;
    }
  }

  return sshConfigs;
};

const runCommands = async(cmds, options, cwd) => {
  if (cmds) {
    cmds.forEach(async (line) => {
      require('child_process').execSync(parseTpl(line, options), {cwd, stdio: 'inherit'});
    });
  }
};

// read config from file
const readOptions = async () => {
  let configFilePath, config = null;

  if(argv.config) {
    configFilePath = path.resolve(process.cwd(), argv.config);
  } else if(await existsFile(path.resolve(process.cwd(), 'deploy-cnf.json'))) {
    configFilePath = path.resolve(process.cwd(), 'deploy-cnf.json');
  }

  if(configFilePath) {
    config = await readJson(configFilePath);
  }

  if(!config) {
    throw new Error('missing config, use "ideploy --help" to see how to pass config.');
  }

  const onlineType = argv.onlineType;
  const configDir = path.dirname(configFilePath);

  // build code
  const sourceProjectDir = config.srcDir? path.resolve(configDir, config.srcDir): null;
  const sourceStageDir = sourceProjectDir? path.join(sourceProjectDir, config.stageDir || 'target/docker/stage'): null;
  const deployStageName = 'stage';
  const deployDir = path.resolve(configDir, config.depDir || '.');

  // modify config
  config.sshConfigs = resolveSSHConfig(config.sshConfigs, configDir);
  return {
    config,
    configDir,
    project: config.project,
    onlineType,
    sourceProjectDir,
    sourceStageDir,
    deployStageName,
    deployDir,
    pktRepo: argv.pktRepo
  };
};

const getDockerComposeYml = (options, instObj) => {
  return instObj.dockerComposeYml? path.resolve(options.configDir, argv.dockerComposeYml || instObj.dockerComposeYml): null;
};

const getDeployList = (options) => {
  // deploy to servers
  var instList = options.config.instances[options.onlineType];

  // can filter by host variable
  if(argv.host || process.env['HOST']) {
    instList = instList.filter(({host}) => host === (argv.host || process.env['HOST']));
  }

  return instList;
};

(async () => {
  const options = await readOptions();
  await runCommands(_.get(options, 'config.hooks.pre'), options, options.configDir);

  const prepareCode = async () => {
    // build code
    return await buildCode(options);
  };

  const publishInsts = () => {
    return Promise.all(getDeployList(options).map(async (inst) => {
      const instObj = _.assign({}, inst,
        resolveConfigDef(options.config.def, {
          env: options.onlineType,
          project: options.project
        }));

      const obj = _.assign(
        {},
        options,
        instObj,
        {
          sshConfig: options.config.sshConfigs[instObj.host],
          dockerComposeYml: getDockerComposeYml(options, instObj),
        });

      // run pre-deploy
      await runCommands(_.get(obj, 'config.hooks.preDeploy'), obj, obj.configDir);
      await deployToServer(obj);
      // run after deploy
      await runCommands(_.get(obj, 'config.hooks.afterDeploy'), obj, obj.configDir);
    }));
  };

  if(argv.buildOnly) {
    await prepareCode();
  } else if(argv.publishOnly) {
    await publishInsts();
  } else {
    await prepareCode();
    await publishInsts();
  }
})();
