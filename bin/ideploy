#!/usr/bin/env node

const _ = require('lodash');
const {deployToServer, buildCode} = require('..');
const {getUserHome, readJson, existsFile, parseTpl} = require('../src/util');
const yargs = require('yargs');
const fs = require('fs');
const path = require('path');
const log = console.log; // eslint-disable-line

yargs.usage(`Usage: ideploy
  --config        config json file path
  --env           used for config
  --buildOnly     build only
  --publishOnly   publish only
  --onlineType    online type, production, staging, ...
  --pktRepo       pkt repo
    `).help('h').alias('h', 'help');

const {
  argv
} = yargs;

const resolveSSHConfig = (sshConfigs, configDir) => {
  if(!sshConfigs) {
    throw new Error('missing configuration of sshConfigs');
  }

  const defaultPrivateKeyFile = path.resolve(getUserHome(), '.ssh/id_rsa');

  for(let name in sshConfigs) {
    const obj = sshConfigs[name];
    const options = obj.options;
    // resolve private key
    if(!options.privateKey) {
      options.privateKeyFile = options.privateKeyFile || defaultPrivateKeyFile;
      options.privateKey = fs.readFileSync(path.resolve(configDir, options.privateKeyFile), 'utf-8');
      delete options.privateKeyFile;
    }
    obj.options = options;

    // resolve proxy private key
    const proxyOptions = obj.proxyOptions;
    if(proxyOptions) {
      if(!proxyOptions.privateKey) {
        proxyOptions.privateKeyFile = proxyOptions.privateKeyFile || defaultPrivateKeyFile;
        proxyOptions.privateKey = fs.readFileSync(path.resolve(configDir, proxyOptions.privateKeyFile), 'utf-8');
        delete proxyOptions.privateKeyFile;
      }
      obj.proxyOptions = proxyOptions;
    }
  }

  return sshConfigs;
};

const runCommands = async(cmds, options, cwd) => {
  if (cmds) {
    cmds.forEach(async (line) => {
      require('child_process').execSync(parseTpl(line, options), {cwd, stdio: 'inherit'});
    });
  }
};

const readOptions = async () => {
  // read config file
  let configFilePath, config = null;

  if(argv.config) {
    configFilePath = path.resolve(process.cwd(), argv.config);
  } else if(await existsFile(path.resolve(process.cwd(), 'deploy-cnf.json'))) {
    configFilePath = path.resolve(process.cwd(), 'deploy-cnf.json');
  }

  if(configFilePath) {
    config = await readJson(configFilePath);
  }

  if(!config) {
    throw new Error('missing config, use "ideploy --help" to see how to pass config.');
  }

  // merge argv
  config = _.assign({
    // some default values
    deployStageName: 'stage',
    stageDir: 'target/docker/stage',
    depDir: '.'
  }, config, argv);

  const configDir = path.dirname(configFilePath);
  const sourceProjectDir = config.srcDir? path.resolve(configDir, config.srcDir): null;

  return _.assign(config, {
    configDir,
    sourceProjectDir,
    sourceStageDir: sourceProjectDir? path.join(sourceProjectDir, config.stageDir): null,
    deployDir: path.resolve(configDir, config.depDir),
    sshConfigs: resolveSSHConfig(config.sshConfigs, configDir)
  }, argv);
};

const getDockerComposeYml = (options, instObj) => {
  if(!instObj.dockerComposeYml && !argv.dockerComposeYml) return null;
  if(argv.dockerComposeYml) {
    return path.resolve(process.cwd(), parseTpl(argv.dockerComposeYml, options));
  } else {
    return path.resolve(options.configDir, parseTpl(instObj.dockerComposeYml, options));
  }
};

const getDeployList = (options) => {
  // deploy to servers
  var instList = options.instances[options.onlineType];

  // can filter by host variable
  if(argv.host || process.env['HOST']) {
    instList = instList.filter(({host}) => host === (argv.host || process.env['HOST']));
  }

  return instList;
};

(async () => {
  const options = await readOptions();
  await runCommands(_.get(options, 'hooks.pre'), options, options.configDir);

  const prepareCode = async () => {
    // build code
    return await buildCode(options);
  };

  const publishInsts = () => {
    return Promise.all(getDeployList(options).map(async (inst) => {
      const instObj = _.assign({}, inst,{
        remoteDir: parseTpl(options.def.remoteDir, options),
        dockerComposeYml: options.def.dockerComposeYml,
        startCommand: options.def.startCommand && parseTpl(options.def.startCommand, options)
      });

      const obj = _.assign(
        {},
        options,
        instObj,
        {
          sshConfig: options.sshConfigs[instObj.host],
          dockerComposeYml: getDockerComposeYml(options, instObj),
        });

      // run pre-deploy
      await runCommands(_.get(obj, 'hooks.preDeploy'), obj, obj.configDir);
      await deployToServer(obj);
      // run after deploy
      await runCommands(_.get(obj, 'hooks.afterDeploy'), obj, obj.configDir);
    }));
  };

  if(argv.buildOnly) {
    await prepareCode();
  } else if(argv.publishOnly) {
    await publishInsts();
  } else {
    await prepareCode();
    await publishInsts();
  }
})();
