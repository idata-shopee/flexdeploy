#!/usr/bin/env node

const _ = require('lodash');
const {deployToServer, buildCode} = require('..');
const {getUserHome, readJson, existsFile, parseTpl} = require('../src/util');
const yargs = require('yargs');
const fs = require('fs');
const path = require('path');
const log = console.log; // eslint-disable-line

yargs.usage(`Usage: ideploy
  --config         config json file path
  --machineConfig  machine config file path
  --env            used for config
  --buildOnly      build only
  --publishOnly    publish only
  --onlineType     online type, production, staging, ...
  --pktRepo        pkt repo
    `).help('h').alias('h', 'help');

const {
  argv
} = yargs;

const resolveSSHConfig = (sshConfigs, configDir) => {
  if(!sshConfigs) {
    throw new Error('missing configuration of sshConfigs');
  }

  const defaultPrivateKeyFile = path.resolve(getUserHome(), '.ssh/id_rsa');

  for(let name in sshConfigs) {
    const obj = sshConfigs[name];
    const options = obj.options;
    // resolve private key
    if(!options.privateKey) {
      options.privateKeyFile = options.privateKeyFile || defaultPrivateKeyFile;
      options.privateKey = fs.readFileSync(path.resolve(configDir, options.privateKeyFile), 'utf-8');
      delete options.privateKeyFile;
    }
    obj.options = options;

    // resolve proxy private key
    const proxyOptions = obj.proxyOptions;
    if(proxyOptions) {
      if(!proxyOptions.privateKey) {
        proxyOptions.privateKeyFile = proxyOptions.privateKeyFile || defaultPrivateKeyFile;
        proxyOptions.privateKey = fs.readFileSync(path.resolve(configDir, proxyOptions.privateKeyFile), 'utf-8');
        delete proxyOptions.privateKeyFile;
      }
      obj.proxyOptions = proxyOptions;
    }
  }

  return sshConfigs;
};

const runCommands = async(cmds, options, cwd) => {
  if (cmds) {
    await Promise.all(cmds.map(async (line) => {
      require('child_process').execSync(parseTpl(line, options), {cwd, stdio: 'inherit'});
    }));
  }
};

const getConfigFilePath = async () => {
  let configFilePath;

  if(argv.config) {
    configFilePath = path.resolve(process.cwd(), argv.config);
  } else if(await existsFile(path.resolve(process.cwd(), 'deploy-cnf.json'))) {
    configFilePath = path.resolve(process.cwd(), 'deploy-cnf.json');
  }

  return configFilePath;
};

const getMachineConfig = async () => {
  if (argv.machineConfig) {
    const machineConfigFilePath = path.resolve(process.cwd(), argv.machineConfig);
    return await readJson(machineConfigFilePath);
  }
};

const readOptions = async () => {
  // read config file
  const configFilePath = await getConfigFilePath();
  let config = null;

  if(configFilePath) {
    config = await readJson(configFilePath);
  }

  if(!config) {
    throw new Error('missing config, use "ideploy --help" to see how to pass config.');
  }

  // merge machine config
  config = _.assign(config, await getMachineConfig() || {});

  // merge argv
  config = _.assign({
    // some default values
    deployStageName: 'stage',
    stageDir: 'target/docker/stage',
    depDir: '.'
  }, config, argv);

  const configDir = path.dirname(configFilePath);
  const sourceProjectDir = config.srcDir? path.resolve(configDir, config.srcDir): null;

  return _.assign(config, {
    configDir,
    sourceProjectDir,
    sourceStageDir: sourceProjectDir? path.join(sourceProjectDir, config.stageDir): null,
    deployDir: path.resolve(configDir, config.depDir),
    sshConfigs: resolveSSHConfig(config.sshConfigs, configDir)
  }, argv);
};

const getDockerComposeYml = (options, instObj) => {
  if(!instObj.dockerComposeYml && !argv.dockerComposeYml) return null;
  if(argv.dockerComposeYml) {
    return path.resolve(process.cwd(), parseTpl(argv.dockerComposeYml, options));
  } else {
    return path.resolve(options.configDir, parseTpl(instObj.dockerComposeYml, options));
  }
};

const getDeployList = (options) => {
  // deploy to servers
  var instList = options.instances[options.onlineType];

  // can filter by host variable
  if(argv.host || process.env['HOST']) {
    instList = instList.filter(({host}) => host === (argv.host || process.env['HOST']));
  }

  return instList;
};

(async () => {
  try {
    const options = await readOptions();
    await runCommands(_.get(options, 'hooks.pre'), options, options.configDir);

    const prepareCode = async () => {
      // build code
      return await buildCode(options);
    };

    const publishInsts = () => {
      return Promise.all(getDeployList(options).map(async (inst) => {
        const instObj = _.assign({}, inst,{
          remoteDir: parseTpl(options.def.remoteDir, options),
          dockerComposeYml: options.def.dockerComposeYml,
          startCommand: options.def.startCommand && parseTpl(options.def.startCommand, options)
        });

        const obj = _.assign(
          {},
          options,
          instObj,
          {
            sshConfig: options.sshConfigs[instObj.host],
            dockerComposeYml: getDockerComposeYml(options, instObj),
          });

        // run pre-deploy
        await runCommands(_.get(obj, 'hooks.preDeploy'), obj, obj.configDir);
        await deployToServer(obj);
        // run after deploy
        await runCommands(_.get(obj, 'hooks.afterDeploy'), obj, obj.configDir);
      }));
    };

    if(argv.buildOnly) {
      await prepareCode();
    } else if(argv.publishOnly) {
      await publishInsts();
    } else {
      await prepareCode();
      await publishInsts();
    }
  } catch(err) {
    log(`[errored] ${err.stack}`);
    process.exit(1);
  }
})();
