#!/usr/bin/env node

const {deployToServer, buildCode} = require('..');
const {readJson, info, existsFile, exec, parseTpl} = require('../src/util');
const yargs = require('yargs');
const fs = require('fs');
const path = require('path');
const log = console.log; // eslint-disable-line

yargs.usage(`Usage: ideploy
  --config        config json file path
  --env           used for config
  --buildOnly     build only
  --publishOnly   publish only
  --onlineType    online type, production, staging, ...
    `).help('h').alias('h', 'help');

const {
  argv
} = yargs;

const resolveConfigDef = (def, obj) => {
  const ret = {};

  if(def.remoteDir) {
    ret.remoteDir = parseTpl(def.remoteDir, obj);
  }

  if(def.dockerComposeYml) {
    ret.dockerComposeYml = parseTpl(def.dockerComposeYml, obj);
  }

  if(def.healthJob) {
    ret.healthJob = (def.healthJob || []).map((item) => parseTpl(item, obj));
  }

  return ret;
};

function getUserHome() {
  return process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];
}

const resolveSSHConfig = (sshConfigs, configDir) => {
  if(!sshConfigs) {
    throw new Error('missing configuration of sshConfigs');
  }

  const defaultPrivateKeyFile = path.resolve(getUserHome(), '.ssh/id_rsa');

  for(let name in sshConfigs) {
    const obj = sshConfigs[name];
    const options = obj.options;
    const proxyOptions = obj.proxyOptions;
    if(!options.privateKey) {
      options.privateKeyFile = options.privateKeyFile || defaultPrivateKeyFile;
      options.privateKey = fs.readFileSync(path.resolve(configDir, options.privateKeyFile), 'utf-8');
      delete options.privateKeyFile;
    }
    obj.options = options;

    if(proxyOptions) {
      if(!proxyOptions.privateKey) {
        proxyOptions.privateKeyFile = proxyOptions.privateKeyFile || defaultPrivateKeyFile;
        proxyOptions.privateKey = fs.readFileSync(path.resolve(configDir, proxyOptions.privateKeyFile), 'utf-8');
        delete proxyOptions.privateKeyFile;
      }
      obj.proxyOptions = proxyOptions;
    }
  }

  return sshConfigs;
};

const runPreHooks = (config, configFilePath, cwd) => {
  if(config.hooks && config.hooks.pre) {
    config.hooks.pre.reduce((prev, line) => {
      return prev.then(() => {
        return exec(line, {
          cwd
        });
      });
    }, Promise.resolve());
  }

  return Promise.resolve();
};

(async () => {
  let configFilePath, config = null;

  if(argv.config) {
    configFilePath = path.resolve(process.cwd(), argv.config);
  } else if(await existsFile(path.resolve(process.cwd(), 'deploy-cnf.json'))) {
    configFilePath = path.resolve(process.cwd(), 'deploy-cnf.json');
  }

  if(configFilePath) {
    config = await readJson(configFilePath);
  }

  /**
   * instances = {
   *   [onlineType]: [argv]
   * }
   *
   * default env = onlineType
   */
  if(config) {
    const onlineType = argv.onlineType;
    const configDir = path.dirname(configFilePath);
    await runPreHooks(config, configFilePath, path.dirname(configFilePath));

    // build code
    const sourceProjectDir = path.resolve(configDir, config.srcDir);
    const sourceStageDir = path.join(sourceProjectDir, 'target/docker/stage');
    const deployStageName = 'stage';
    const deployDir = path.resolve(configDir, config.depDir || '.');

    // modify config
    config.sshConfigs = resolveSSHConfig(config.sshConfigs, configDir);

    const prepareCode = async () => {
      // build code
      return await buildCode({
        project: config.project,
        onlineType,
        sourceProjectDir,
        sourceStageDir,
        deployStageName,
        deployDir
      });
    };

    const publishInsts = () => {
      // deploy to servers
      var instList = config.instances[argv.onlineType];

      if(argv.host || process.env['HOST']) {
        instList = instList.filter(({host}) => host === (argv.host || process.env['HOST']));
      }

      const deployInst = (inst) => {
        const instObj = Object.assign(resolveConfigDef(config.def, {
          env: inst.env || onlineType,
          project: config.project
        }), inst);
        info('inst obj', `${JSON.stringify(instObj, null, 4)}`);
        // check inst options
        if(!config.sshConfigs || !config.sshConfigs[instObj.host]) {
          throw new Error(`missing sshConfigs for host ${instObj.host}.`);
        }

        const obj = {
          deployStageName,
          deployDir,
          host: instObj.host,
          remoteDir: instObj.remoteDir,
          dockerComposeYml: path.resolve(configDir, argv.dockerComposeYml || instObj.dockerComposeYml),
          sshConfig: config.sshConfigs[instObj.host] // TODO read local ssh config file
        };

        info('options', `${JSON.stringify(obj, null, 4)}`);
        return deployToServer(obj);
      };

      // concurrent
      return Promise.all(instList.map(deployInst));
      // sequencial
      // return instList.reduce((p, inst) => {
      //   return p.then(() => deployInst(inst));
      // }, Promise.resolve());
    };

    if(argv.buildOnly) {
      await prepareCode();
    } else if(argv.publishOnly) {
      await publishInsts();
    } else {
      await prepareCode();
      await publishInsts();
    }
  }
})();
